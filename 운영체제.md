 # 운영체제

 오늘 남은시간 12시간
 공부 시작시간 12:40분
 예상 운체 공부시간: 4시간
 범위: 7-12단원 335-621p

 ## 목차
 * 7단원 : 메모리 관리
 * 8단원 : 가상 메모리
 * 9단원 : 단일처리기 스케줄링
 * 10단원 : 멀티프로세서, 멀티코어 및 실시간 스케줄링
 * 11단원 : 입출력 관리와 디스크 스케줄링
 * 12 단원 : 파일 관리

 ## 주요 용어 정리

 ### 7단원: 메모리 관리
 * 프레임(Frame) : 주기억장치의 고정 길이 블록
 * 페이지(Page) : 보조기억장치의 고정 길이 블록
 * 세그먼트(segment) : 보조기억장치의 가변 길이 블록

메모리 관리 요구조건
 * 재배치(Relocation) : 주기억장치로 swap-in swap-out할때 메모리의 다른 공간으로 프로세스를 재배치 할 수 있음
 * 보호(Protection) : 다른 프로세스에 속한 프로그램들을 허가 없이 읽기나 쓰기를 할 수 없음(하드웨어에 의해 이루어짐)
 * 공유(Sharing) : 협력하는 프로세스는 같은 데이터 구조에 접근할 수 있다.
 * 논리적 구성(Logical organization) : 프로그램은 모듈로 구성되며 실제 하드웨어에서 구성하는 방법과 일치하지 않는다. 모듈을 효과적으로 처리할 수 있다면 다양한 이점을 얻을 수 있다.(세그먼트(segment)에 의해 구현 가능)
 * 물리적 구성(Physical organization) : 주기억장치와 보조기억장치라는 두 계층의 정보흐름을 어떻게 구성하느냐가 시스템이 가져야할 책임이며 메모리 관리의 핵심기능이다.

 메모리 분할
 * 고정분할 : 고정된 경계를 가지는 메모리 영역으로 분리
    * 균등분할 : 각 분할이 모두 같은 크기를 가짐
    * 비균등 분할 : 각 분할이 다른 크기를 가짐
 * 내부 단편화 : 고정분할을 할 때 생기는 현상으로 적재되는 데이터가 파티션보다 작을 때 파티션 내부 공간 낭비가 발생하는 현상
 * 고정분할 배치 알고리즘
    각 프로세스 용량에 맞는 가장 작은 파티션을 할당
    * 파티션당 하나의 프로세스 큐
    * 단일 큐
<br>
* 동적분할 : 프로세스가 주기억장치로 적재될 때 정확히 요구 된 크기만큼 메모리를 할당받음
* 외부 단편화 : 프로세스들이 swap-in swap-out 하면서 주기억장치에 작은 구멍들이 만들어져 파티션 영역 이외의 메모리가 점차 사용할 수 없는 조각으로 변하는 현상
* 메모리 집약(compaction) : 각 파티션이 연속적이 되도록 인접하게 만들고, 메모리의 모든 빈 공간이 하나의 블록이 되도록 함.
* 동적분할 배치 알고리즘
  * best-fit : 요청된 크기와 가장 근접한 크기의 메모리 선택
  * first-fit : 크기가 충분한 첫번째 사용가능한 메모리 블록 선택
  * next-fit : 가장 최근에 배치됬던 메모리 위치부터 시작하여 다음위치에서 크기가 충분한 메모리 블록 선택
<br>
* 버디시스템 : 고정분할과 동적분할의 절충안
* 게으른 버디시스템(lazy buddy):
* 페이징 : 주기억장치를 작은 크기의 고정 사이즈 파티션으로 나누고(프레임) 프로세스도 작은 크기의 고정 조각(페이지)으로 나누어 메모리에 적재하는 방식
* 세그먼트 : 프로세스를 관련된 데이터들의 묶음(세그먼트)로 나누어 주 기억장치에 올리는 방식. (동적분할과 유사하지만 세그먼트의 크기가 상대적으로 작기 때문에 외부단편화도 상대적으로 작다)


 ### 8단원 : 가상메모리

* 가상메모리 : 보조기억장치를 주기억장치처럼 주소지정을 가능하게 만든 저장공간 할당체제
* 가상주소 : 주기억장치 처럼 참조될 수 있도록 가상메모리 특정위치에 배정된 주소
* 가상주소공간 : 특정프로세스에게 할당된 가상주소의 영역
* 실주소 : 주기억장치상의 특정 저장위치의 주소
* 적재집합(resident set) : 프로세스 코드나 데이터 중 임의시점에 주기억장치에 적재되어 있는 부분.
* 쓰레싱(thrashing) : 주기억장치 전체가 블록들로 꽉찼을 때 한 블록이 반입되려면 다른 불록이 반출되어야 한다. 만약 특정블록이 사용되기 직전에 반출되었다면, 그 블록은 곧바로 다시 반입되게 된다. 이러한 일이 과도하게 발생하는 것을 thrashing이라 한다.
* 지역성의 원리: 프로세스 내의 명령어 및 데이터에 대한 참조가 군집화 경향이 있음.
* 페이지테이블 : 가상주소(페이지번호 + 오프셋)를 물리주소로 변환시키는 테이블로 메모리에 저장되어 있음(페이지번호, 프로세스 식별자, 제어비트, 체크포인터 로 구성)
* TLB(Translation Lookaside buffer): 모든 가상메모리 참조는 적어도 두번의 메모리 참조를 수반하는데 너무 느리기 때문에 페이지 항목들에 대해 특수한 고속캐시를 사용하는데 이를 TLB라 부른다. (페이지테이블의 일부항목만 포함하기 때문에 페이지 번호를 인덱스로 사용 불가)(페이지테이블 항목의 내용 + 페이지번호 로 구성)
* 연관사상(associative mapping) : 특정페이지 번호와 일치하는 TLB항목이 있는지 검사하기 위해 TLB항목을 동시에 조사하는 하드웨어가 장착시키는 기법
* 직접사상(direct mapping) : 인덱스로 접근하는 방식

* 반입정책(Fetch Policy) : 각 페이지를 언제 주 기억장치로 적재할 지 결정
  * 요구페이징(demand paging) : 페이지가 주 기억장치로 반입되는 시점은 해당 페이지의 일부가 참조될 때 이다.
  * 선 페이징(prepaging) : 페이지폴트에의해 요구된 페에지들 이외의 페이지들도 반입
  * 스왑핑(swapping) : 프로세스가 swap-out 되어 보류상태로 놓이게 되면 그 프로세스르르 위해 적재된 페이지들 모두가 한꺼번에 주기억장치 밖으로 나가게 된다. 다시 프로세스 수행이 재개되면 나갔던 것 모두가 다시 들어오게 된다.

* 교체정책(Replacement Policy) : 어떤 블록을 교체 대상으로 선택할 것인가
  * 최적(optimal) : 미래에 참조될 때까지의 시간이 가장 긴 페이지 선정(구현 불가능, 평가를 위해 사용)
  * LRU(Least Recently Used) : 가장 오랜 시간동안 참조되지 않은 주기억장치상의 페이지 교체(비용이 큼)
  * FIFO(First-In-First-Out) : 라운드로빈 스타일로 프레임상의 페이지를 제거
  * Clock : LRU의 오버헤드와 FIFO의 성능을 보완한 알고리즘으로 각 프레임에 usebit를 연계시킨다.환형 버퍼를 구성하고 있고 처음 페이지가 주 메모리로 들어오면 usebit를 1로 설정하고 하나의 포인터가 있어 교체후보를 가리킨다. 교체후보를 찾을때 usebit가 0인 프레임을 찾아서 교체대상으로 선정해주는데 만약 1인 usebit를 만난다면 0으로 교체하고 다음프레임으로 진행한다.
  * 변형된 Clock : 기존 Clock 알고리즘에서 modify bit를 추가하여 진행한다. 상태는 4가지가 있는데 (usebit, modifybit) 라고 할때 (0,0) (1,0) (0,1) (1,1)로 나타낼 수 있다. 진행은 usebit를 변경하지 않으면서 (0,0)인 프레임을 찾고 만약 못찾았다면 (0,1)인 프레임을 찾으며 스캔하되 usebit가 1인 프레임을 만나면 0으로 바꿔주면서 진행한다. 이렇게해서 찾지 못했다면 다시 이 과정을 반복하게 되면 찾을 수 있다.

  * 페이지 버퍼링(Page Buffering) : 페이지가 바로 보조기억장치로 swap-out되는 것이 아니라 교체대상으로 선정되었을 때 변경되지 않은 페이지는 가용페이지 리스트에 변경된 페이지는 변경페이지 리스트에 연결시켜 관리한다. 물리적으로 이동하는 것이 아니라 페이지에 대한 사상정보가 페이지 테이블 항목으로 부터 제거되고 관련정보가 가용페이지 리스트나 변경 페이지 리스트에 연결되는 것이다. 새로운 페이지가 반입도리 때 가용페이지 리스트 맨 앞쪽의 첫 프레임이 사용되어 그 내용이 덮여 쓰이게 된다. 또한 변경된 페이지는 클러스터로 묶여서 기록될 수 있고 이로 인해 입출력 연산이 크게 줄어든다.

* 적재집합 관리 : 프로세스의 모든 페이지를 주기억장치에 적재할 필요가 없기 때문에 어떤페이지를 반입해야할지 결정해야한다.
* 할당 방식
  * 고정할당(fixed-allocation) : 프로세스 생성시점에서 결정하며 고정개수의 페이지 프래임을 할당한다.
  * 가변할당(variable-allocation) : 프로세스에 할당된 페이지 프레임수의 변경을 허용한다.
* 교체범위
  * 지역 교체 정책(local replacement policy) : 페에지폴트를 발생시킨 프로세스의 적재페이지중에 교체대상 페이지 선정
  * 전역 교체 정책(global replacement policy) : 주기억장치상의 모든페이지를 교체 후보로 고려
  * 작업집합 전략(working set strategy) : 가변할당/지역범위 에서 사용되는 개념으로 일정시간 동안 수행되면서 특정 시점 t에서의 참조된 페이지들의 집합으로 적재집합의 크기를 결정하는 전략의 지침이 될 수 있다.
    * PFF(Page Fault Frequency) : 메모리는 각 페이지와 연관된 사용비트를 필요로 하며 사용비트는 해당 페이지가 참조될 때 1로 설정된다. 프로세스가 페이지 폴트를 발생시킬 때 운영체제는 해당 프로세스가 직전에 페이지폴트를 발생시켰던 시점으로부터의 가상시간을 관찰하는데, 이는 페이지 참조 카운터를 유지한다면 간능하다. 경과시간이 임계치보다 작다면 해당 페이지 적재집합에 한 페이지가 추가된다. 임계치보다 크다면 사용비트가 0인 모든페이지가 버려져 적재집합이 그만큼 축소되며 며려지지 않은 페이지는 모두 0으로 설정된다.
    * VSWS(Variable-interval Sampled Working Set)  
* 클리닝 정책(Cleaning Policy) : 변경된 장치 중 어떤 것을 보조기억장치에 기록할 것인지를 결정
  * 요구클리닝(demand cleaning) : 교체대상으로 선택되었을 때 기록
  * 선 클리닝(pre cleaning) : 미리 기록
* 부하제어(Load Control) : 주기억장치에 적재될 프로세스의 수를 결정
  * 멀티프로그래밍 수준(Multiprogramming Level)
  * 프로세스 보류(processSuspension) : 멀티프로그래밍의 차수를 감소시키려면, 현재 적재된 프로세스들 중 하나 이상을 보류시켜야 한다. 어떤 프로세스를 보류시킬까?
    * 최저 우선순위 프로세스 : 성능 이슈 없음
    * 가장 최근에 활성화된 프로세스 : 작업집합을 확보할 가능성 가장 적음
    * 폴트 발생 프로세스 : 폴트를 발생시킨 프로세스가 그 작업집합을 적재하고 있을 가능성 적음
    * 최소 적재집합을 가진 프로세스 : 미래의 재적재 비용 최소화
    * 가장 큰 프로세스 : 비활성화 작업에 대한 추가수행 필요성 줄여줌
    * 잔여 수행 윈도우가 가장 큰 프로세스 : shortest-processing-time-first 스케줄링과 유사
 ### 9단원 : 단일처리기 스케줄링
  * 처리기 스케줄링 유형
    * 장기 : 실행된 프로세스를 활성상태(준비/보류 혹은 준비상태)로 보내주는 스케줄링
    * 중기 : swapping 과정에서 사용되는 스케줄러로 무엇을 주기억장치에 적재할지 정해주는 스케줄러
    * 단기 : CPU에게 던져주는 스케줄러 (주로 이 내용을 다룸)
  * 단기 스케줄링 알고리즘
    * 평가기준
      * 사용자 기준 : (정량적)응답시간, 반환시간, 완료기한 (정성적)예측 가능성
      * 시스템 기준 : (정량적)처리량, 처리기 이용률 (정성적) 공정성, 우선순위의 부여, 균형있는 자원
    * 우선순위 기반 스케줄링
  * 선택함수(selection function)을 이용한 스케줄링
    * 비선점모드
      * FCFS : 비효율적
      * SPN(Shortest Process Next)
    * 선점모드
      * Round Robin : time slicing(time quantum)기법 사용
      * SRT(Shortest Remaining Time)
      * HRRN(Highest Response Ratio Next)
      * multilevel feedback
      * FSS(Fair Share Sceduling)
    * 성능비교
      * Queuing Analysis(큐잉분석)
      * simulation Modeling(시뮬레이션 모델링)

  * 용어
    * 상주시간(residence time) : 대기시간 + 실행시간
