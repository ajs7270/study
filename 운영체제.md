 # 운영체제

 오늘 남은시간 12시간
 공부 시작시간 12:40분
 예상 운체 공부시간: 4시간
 범위: 7-12단원 335-621p

 ## 목차
 * 7단원 : 메모리 관리
 * 8단원 : 가상 메모리
 * 9단원 : 단일처리기 스케줄링
 * 10단원 : 멀티프로세서, 멀티코어 및 실시간 스케줄링
 * 11단원 : 입출력 관리와 디스크 스케줄링
 * 12 단원 : 파일 관리

 ## 주요 용어 정리

 ### 7단원: 메모리 관리
 * 프레임(Frame) : 주기억장치의 고정 길이 블록
 * 페이지(Page) : 보조기억장치의 고정 길이 블록
 * 세그먼트(segment) : 보조기억장치의 가변 길이 블록

메모리 관리 요구조건
 * 재배치(Relocation) : 주기억장치로 swap-in swap-out할때 메모리의 다른 공간으로 프로세스를 재배치 할 수 있음
 * 보호(Protection) : 다른 프로세스에 속한 프로그램들을 허가 없이 읽기나 쓰기를 할 수 없음(하드웨어에 의해 이루어짐)
 * 공유(Sharing) : 협력하는 프로세스는 같은 데이터 구조에 접근할 수 있다.
 * 논리적 구성(Logical organization) : 프로그램은 모듈로 구성되며 실제 하드웨어에서 구성하는 방법과 일치하지 않는다. 모듈을 효과적으로 처리할 수 있다면 다양한 이점을 얻을 수 있다.(세그먼트(segment)에 의해 구현 가능)
 * 물리적 구성(Physical organization) : 주기억장치와 보조기억장치라는 두 계층의 정보흐름을 어떻게 구성하느냐가 시스템이 가져야할 책임이며 메모리 관리의 핵심기능이다.

 메모리 분할
 * 고정분할 : 고정된 경계를 가지는 메모리 영역으로 분리
    * 균등분할 : 각 분할이 모두 같은 크기를 가짐
    * 비균등 분할 : 각 분할이 다른 크기를 가짐
 * 내부 단편화 : 고정분할을 할 때 생기는 현상으로 적재되는 데이터가 파티션보다 작을 때 파티션 내부 공간 낭비가 발생하는 현상
 * 고정분할 배치 알고리즘
    각 프로세스 용량에 맞는 가장 작은 파티션을 할당
    * 파티션당 하나의 프로세스 큐
    * 단일 큐
<br>
* 동적분할 : 프로세스가 주기억장치로 적재될 때 정확히 요구 된 크기만큼 메모리를 할당받음
* 외부 단편화 : 프로세스들이 swap-in swap-out 하면서 주기억장치에 작은 구멍들이 만들어져 파티션 영역 이외의 메모리가 점차 사용할 수 없는 조각으로 변하는 현상
* 메모리 집약(compaction) : 각 파티션이 연속적이 되도록 인접하게 만들고, 메모리의 모든 빈 공간이 하나의 블록이 되도록 함.
* 동적분할 배치 알고리즘
  * best-fit : 요청된 크기와 가장 근접한 크기의 메모리 선택
  * first-fit : 크기가 충분한 첫번째 사용가능한 메모리 블록 선택
  * next-fit : 가장 최근에 배치됬던 메모리 위치부터 시작하여 다음위치에서 크기가 충분한 메모리 블록 선택
<br>
* 버디시스템 : 고정분할과 동적분할의 절충안
* 게으른 버디시스템(lazy buddy):
* 페이징 : 주기억장치를 작은 크기의 고정 사이즈 파티션으로 나누고(프레임) 프로세스도 작은 크기의 고정 조각(페이지)으로 나누어 메모리에 적재하는 방식
* 세그먼트 : 프로세스를 관련된 데이터들의 묶음(세그먼트)로 나누어 주 기억장치에 올리는 방식. (동적분할과 유사하지만 세그먼트의 크기가 상대적으로 작기 때문에 외부단편화도 상대적으로 작다)


 ### 8단원 : 가상메모리

* 가상메모리 : 보조기억장치를 주기억장치처럼 주소지정을 가능하게 만든 저장공간 할당체제
* 가상주소 : 주기억장치 처럼 참조될 수 있도록 가상메모리 특정위치에 배정된 주소
* 가상주소공간 : 특정프로세스에게 할당된 가상주소의 영역
* 실주소 : 주기억장치상의 특정 저장위치의 주소
* 적재집합(resident set) : 프로세스 코드나 데이터 중 임의시점에 주기억장치에 적재되어 있는 부분.
* 쓰레싱(thrashing) : 주기억장치 전체가 블록들로 꽉찼을 때 한 블록이 반입되려면 다른 불록이 반출되어야 한다. 만약 특정블록이 사용되기 직전에 반출되었다면, 그 블록은 곧바로 다시 반입되게 된다. 이러한 일이 과도하게 발생하는 것을 thrashing이라 한다.
* 지역성의 원리: 프로세스 내의 명령어 및 데이터에 대한 참조가 군집화 경향이 있음.
* 페이지테이블 : 가상주소(페이지번호 + 오프셋)를 물리주소로 변환시키는 테이블로 메모리에 저장되어 있음(페이지번호, 프로세스 식별자, 제어비트, 체크포인터 로 구성)
* TLB(Translation Lookaside buffer): 모든 가상메모리 참조는 적어도 두번의 메모리 참조를 수반하는데 너무 느리기 때문에 페이지 항목들에 대해 특수한 고속캐시를 사용하는데 이를 TLB라 부른다. (페이지테이블의 일부항목만 포함하기 때문에 페이지 번호를 인덱스로 사용 불가)(페이지테이블 항목의 내용 + 페이지번호 로 구성)
* 연관사상(associative mapping) : 특정페이지 번호와 일치하는 TLB항목이 있는지 검사하기 위해 TLB항목을 동시에 조사하는 하드웨어가 장착시키는 기법
* 직접사상(direct mapping) : 인덱스로 접근하는 방식

* 반입정책(Fetch Policy) : 각 페이지를 언제 주 기억장치로 적재할 지 결정
  * 요구페이징(demand paging) : 페이지가 주 기억장치로 반입되는 시점은 해당 페이지의 일부가 참조될 때 이다.
  * 선 페이징(prepaging) : 페이지폴트에의해 요구된 페에지들 이외의 페이지들도 반입
  * 스왑핑(swapping) : 프로세스가 swap-out 되어 보류상태로 놓이게 되면 그 프로세스르르 위해 적재된 페이지들 모두가 한꺼번에 주기억장치 밖으로 나가게 된다. 다시 프로세스 수행이 재개되면 나갔던 것 모두가 다시 들어오게 된다.

* 교체정책(Replacement Policy) : 어떤 블록을 교체 대상으로 선택할 것인가
  * 최적(optimal) : 미래에 참조될 때까지의 시간이 가장 긴 페이지 선정(구현 불가능, 평가를 위해 사용)
  * LRU(Least Recently Used) : 가장 오랜 시간동안 참조되지 않은 주기억장치상의 페이지 교체(비용이 큼)
  * FIFO(First-In-First-Out) : 라운드로빈 스타일로 프레임상의 페이지를 제거
  * Clock : LRU의 오버헤드와 FIFO의 성능을 보완한 알고리즘으로 각 프레임에 usebit를 연계시킨다.환형 버퍼를 구성하고 있고 처음 페이지가 주 메모리로 들어오면 usebit를 1로 설정하고 하나의 포인터가 있어 교체후보를 가리킨다. 교체후보를 찾을때 usebit가 0인 프레임을 찾아서 교체대상으로 선정해주는데 만약 1인 usebit를 만난다면 0으로 교체하고 다음프레임으로 진행한다.
  * 변형된 Clock : 기존 Clock 알고리즘에서 modify bit를 추가하여 진행한다. 상태는 4가지가 있는데 (usebit, modifybit) 라고 할때 (0,0) (1,0) (0,1) (1,1)로 나타낼 수 있다. 진행은 usebit를 변경하지 않으면서 (0,0)인 프레임을 찾고 만약 못찾았다면 (0,1)인 프레임을 찾으며 스캔하되 usebit가 1인 프레임을 만나면 0으로 바꿔주면서 진행한다. 이렇게해서 찾지 못했다면 다시 이 과정을 반복하게 되면 찾을 수 있다.

  * 페이지 버퍼링(Page Buffering) : 페이지가 바로 보조기억장치로 swap-out되는 것이 아니라 교체대상으로 선정되었을 때 변경되지 않은 페이지는 가용페이지 리스트에 변경된 페이지는 변경페이지 리스트에 연결시켜 관리한다. 물리적으로 이동하는 것이 아니라 페이지에 대한 사상정보가 페이지 테이블 항목으로 부터 제거되고 관련정보가 가용페이지 리스트나 변경 페이지 리스트에 연결되는 것이다. 새로운 페이지가 반입도리 때 가용페이지 리스트 맨 앞쪽의 첫 프레임이 사용되어 그 내용이 덮여 쓰이게 된다. 또한 변경된 페이지는 클러스터로 묶여서 기록될 수 있고 이로 인해 입출력 연산이 크게 줄어든다.

* 적재집합 관리 : 프로세스의 모든 페이지를 주기억장치에 적재할 필요가 없기 때문에 어떤페이지를 반입해야할지 결정해야한다.
* 할당 방식
  * 고정할당(fixed-allocation) : 프로세스 생성시점에서 결정하며 고정개수의 페이지 프래임을 할당한다.
  * 가변할당(variable-allocation) : 프로세스에 할당된 페이지 프레임수의 변경을 허용한다.
* 교체범위
  * 지역 교체 정책(local replacement policy) : 페에지폴트를 발생시킨 프로세스의 적재페이지중에 교체대상 페이지 선정
  * 전역 교체 정책(global replacement policy) : 주기억장치상의 모든페이지를 교체 후보로 고려
  * 작업집합 전략(working set strategy) : 가변할당/지역범위 에서 사용되는 개념으로 일정시간 동안 수행되면서 특정 시점 t에서의 참조된 페이지들의 집합으로 적재집합의 크기를 결정하는 전략의 지침이 될 수 있다.
    * PFF(Page Fault Frequency) : 메모리는 각 페이지와 연관된 사용비트를 필요로 하며 사용비트는 해당 페이지가 참조될 때 1로 설정된다. 프로세스가 페이지 폴트를 발생시킬 때 운영체제는 해당 프로세스가 직전에 페이지폴트를 발생시켰던 시점으로부터의 가상시간을 관찰하는데, 이는 페이지 참조 카운터를 유지한다면 간능하다. 경과시간이 임계치보다 작다면 해당 페이지 적재집합에 한 페이지가 추가된다. 임계치보다 크다면 사용비트가 0인 모든페이지가 버려져 적재집합이 그만큼 축소되며 며려지지 않은 페이지는 모두 0으로 설정된다.
    * VSWS(Variable-interval Sampled Working Set)  
* 클리닝 정책(Cleaning Policy) : 변경된 장치 중 어떤 것을 보조기억장치에 기록할 것인지를 결정
  * 요구클리닝(demand cleaning) : 교체대상으로 선택되었을 때 기록
  * 선 클리닝(pre cleaning) : 미리 기록
* 부하제어(Load Control) : 주기억장치에 적재될 프로세스의 수를 결정
  * 멀티프로그래밍 수준(Multiprogramming Level)
  * 프로세스 보류(processSuspension) : 멀티프로그래밍의 차수를 감소시키려면, 현재 적재된 프로세스들 중 하나 이상을 보류시켜야 한다. 어떤 프로세스를 보류시킬까?
    * 최저 우선순위 프로세스 : 성능 이슈 없음
    * 가장 최근에 활성화된 프로세스 : 작업집합을 확보할 가능성 가장 적음
    * 폴트 발생 프로세스 : 폴트를 발생시킨 프로세스가 그 작업집합을 적재하고 있을 가능성 적음
    * 최소 적재집합을 가진 프로세스 : 미래의 재적재 비용 최소화
    * 가장 큰 프로세스 : 비활성화 작업에 대한 추가수행 필요성 줄여줌
    * 잔여 수행 윈도우가 가장 큰 프로세스 : shortest-processing-time-first 스케줄링과 유사
 ### 9단원 : 단일처리기 스케줄링
  * 처리기 스케줄링 유형
    * 장기 : 실행된 프로세스를 활성상태(준비/보류 혹은 준비상태)로 보내주는 스케줄링
    * 중기 : swapping 과정에서 사용되는 스케줄러로 무엇을 주기억장치에 적재할지 정해주는 스케줄러
    * 단기 : CPU에게 던져주는 스케줄러 (주로 이 내용을 다룸)
  * 단기 스케줄링 알고리즘
    * 평가기준
      * 사용자 기준 : (정량적)응답시간, 반환시간, 완료기한 (정성적)예측 가능성
      * 시스템 기준 : (정량적)처리량, 처리기 이용률 (정성적) 공정성, 우선순위의 부여, 균형있는 자원
    * 우선순위 기반 스케줄링
  * 선택함수(selection function)을 이용한 스케줄링
    * 비선점모드
      * FCFS : 비효율적
      * SPN(Shortest Process Next)
    * 선점모드
      * Round Robin : time slicing(time quantum)기법 사용
      * SRT(Shortest Remaining Time)
      * HRRN(Highest Response Ratio Next)
      * multilevel feedback
      * FSS(Fair Share Sceduling)
    * 성능비교
      * Queuing Analysis(큐잉분석)
      * simulation Modeling(시뮬레이션 모델링)

  * 용어
    * 상주시간(residence time) : 대기시간 + 실행시간

시작시간 12시 58분
개념 공부 최대 할애 가능시간 : 2시간(이건 진짜 최대)
한 단원당 최대 공부 가능시간 : 2/3시간 = 40분
한 소단원당 최대 공부 가능시간 : 10분(정말 최대)
개념 공부 복습시간 : 30분 (최대)
족보 풀이 시간 : 1시간 (최대)

 ### 10단원 : 멀티프로세서, 멀티코어 및 실시간 스케줄링
 * 클러스터(cluster, loosely-coupled, distributed multiprocessor): 서로 독립적으로 동작하는 개별 시스템들의 모음구조, 각 처리기는 자신만의 주 메모리, 입출력 채널등을 가지고 있다.
 * tightly-coupled multiprocessing: 주 메모리를 공유하는 여러개의 처리기들이 한 시스템 내에 모여잇는 구조(이번장에서 다룸)
 * 동기화 단위(granularity) : 멀티프로세서 시스템만의 특성을 표현하기에 적당한 척도
    크기구분
    * Fine : 한 쓰레드 내에 있는 여러 코드 블록들 간의 병렬성을 의미, 구현하기가 쉽지 않음
    * Medium : 한 프로세스내에 쓰레드들이 서로 상호작용하면서 조화롭게 실행될 수 있는 정도의 병렬성, 쓰레드 스케줄링 정책으로 어떤 알고리즘을 사용하느냐에 따라 프로세스 전체의 성능에 큰 영향을 미친다.
    * Coarse 또는 Very Coarse :프로세스들 간에 동기화가 이루어지긴 하지만 동기화의 단위가 상당히 큰 경우를 의미, 멀티프로그래밍을 지원하는 단일처리기 시스템 상에서 실행되는 병행 프로세스들 간에서 흔히 발견되는 병렬
    * Independent : 프로세스들 간에 명시적인 동기화를 할 피룡가 없는 경우(시분할 시스템에서 주로 사용)
* 설계이슈
    * 프로세스를 어떤 처리기에 할당할 것인가?
      * 동적으로 할당? : 설명 x
      * 정적으로 할당? : 처리기간 부하 불균형 발생가능 ex) gang
    * 누가 처리기 할당을 주도할 것인가?
      * master/slave 방식 : 여러 처리기중 한 처리기 에서만 핵심운영체제 기능이 수행되고 나머지 처리기들은 사용자 프로세스만 실행한다.
      * peer 방식 : 처리기는 스스로 프로세스 스케줄링을 시행한다.(운영체제 커널 복잡해짐)
    * 각 처리기에서 멀티프로그래밍을 지원 할 것인가?
      * Coarse, Very Coarse, Independent : 멀티 프로그래밍 지원하는 게 좋음
      * Medium : 멀티프로그램이 오히려 성능에 도움을 주지 못할 수 있음
    * 다음번 실행 프로세스로 어떤 프로세스를 고를것인가?
      * FCFS : 단순정책이 오버해드가 적기 때문에 더 효과적일 수 있다.
* 프로세스 스케줄링
  * 멀티프로세서 시스템에서는 FCFS가 충분한 성능을 낼 수 있다.
* 쓰레드 스케줄링
  * 단일처리기 시스템에서 쓰레드는 프로그램 구성을 도와주는 조력자 역할이였다면 멀티프로세서 시스템에서는 쓰레드를 사용하여 한 응용프로그램 내에서 진정한 병렬성을 구현할 수 있다. 한 응용프로그램을 구성하는 다양한 쓰레드들이 서로 다른 처리기 상에서 동시에 실행된다면 현저한 성능 향상을 기대할 수 있다. 하지만 쓰레드간 통신이 매우 빈번하게 발생하는 응용프로그램의 경우 쓰레드 관리 방법이나 스케줄링 방법에 따라 시스템에 큰 영향을 줄 수 있다.

  * 처리기 할당을 위한 여러가지 연구
    * Load sharing(부하공유)방식 : 각 처리기에 부하가 공평하게 분산, 실행해야할 쓰레드가 남아있는 한 어떠한 처리기도 쉬지 않음, 스케줄링을 한처리기가 전담하지 않음, 모든 처리기가 액세스 할 수 있는 전역큐를 둠
      * FCFS(비선점) : 새 작업이 도착하면 그 작업에 속해있는 쓰레드들은 전역 공유큐에 연속해서 들어감
      * 쓰레드 개수가 가장 적은 작업 우선(비선점) : 아직 스케줄되지 못한 쓰레드의 갯수가 가장 적은 작업에게 가장 높은 우선순위 부여
      * 쓰레드 개수가 가장 적은 작업 우선(선점): 현재 실행중인 작업보다 더 적은 개수의 쓰레드로 구성된 작업이 들어오면 현재 실행중인 작업은 잠시 선점됨
    * Gang Sceduling : 한번에 여러개의 프로세스를 동시에 여러개의 처리기로 스케줄링하는 방식(그룹 스케줄링) medium이나 fine병렬성을 갖고 있는 응용프로그램을 위한 방식
      * 서로 밀접한 관계가 있는 프로세스가 동시 실행되면 동기화로 인한 블록을 줄일 수 있어 성능 향상
      * 단 한번의 스케줄링으로 여러 프로세스를 한번에 여러 처리기로 스케줄링하기 때문에 스케줄링 오버헤드가 줄어듬
      * 한 응용프로그램 내에 모든 쓰레드가 동시에 실행 중이지 않으면 성능에 치명적인 문제가 발생하는 경우 효과가 큼(병렬 응용프로그램에 효과적)

    * 전용(Dedicated) 처리기 할당 : 갱 스케줄링의 개념을 극단적으로 적용하면 여러 처리기 그룹이 한 응용프로그램이 끝날 때 까지 전담 스케줄링 하도록 할 수 있음
      * activity working set(활성작업집합) : 가상메모리의 working set과 비슷
    * 동적(Dynamic) 스케줄링 : 프로세스내의 쓰래드 개수를 동적으로 조절할 수 있을 경우 처리기 이용률을 높이기 위해 운영체제가 부하를 동적으로 조절할 수 있게 된다.
      * 쉬고있는 처리기 에 항당
      * 쉬고있는거 없다면 두 개 이상의 처리기를 할당받고 있는 작업으로부터 하나 뺏어 할당
      * 기다리거나 요청을 포기


* real-time Sceduling(실시간 스케줄링)
  * real-time task : 지정된 시간동안 실행되고 그 기간동안 외부에서 발생하는 실시간 사건에 대해 반복적으로 반응하는 방식으로 동작하는 것이다.
    * hard real-time task : 데드라인을 반드시 만족해야하는 실시간 테스크
    * soft real-time task : 데드라인을 준수하면 좋지만 어기더라도 큰 문제는 일어나지 않음
    * periodic task : 주기적으로 실행됨 어떤 기간동안 반드시 한번씩 실행됨 또는 한번 실행된 수 반드시 시간 T이내에 실행됨
    * aperiodic task : 비 주기적으로 실행됨
  * 실시간 운영체제의 특성
    * 결정성(Determinism) : 도착한 인터럽트에 운영체제가 반응할 때 까지 얼마나 오랜시간이 걸리느냐
    * 응답성(Responsiveness) : 반응을 시작한 후 얼마나 빨리 그 인터럽트에 대해 서비스를 완료해 줄 수 있느냐
    * 사용자에 의한 제어(User Control) :사용자가 테스크에 우선순위를 매기는 것을 허용
    * 신뢰성(Reliablity)
    * 장애대처(Fail-soft) : stability(안정성)가 중요 모든 테스크의 데드라인을 만족시키지 못하더라도 우선순위가 높은 테스크들의 데드라인 만큼은 보장해 주자

  * 실시간 스케줄링
    * 정적 테이블 기반 방식 : 주기적으로 실행되는 테스크들에 대해 적용되며 스케줄링 여부를 스케줄릴 전 정적으로 분석하는 방식(데드라인 스케줄링에서 사용)
    * 정적 우선순위-기반 선점모드 방식 : 정적으로 실제 스케줄링 전 스케줄링 가능 여부를 분석 하지만 표는 만들지 않음, 그리고 분석결과는 태스크들에 부여할 우선순위를 결정하는 데 활용
    * 동적 계획 기반 방식 : 실행시간에 스케줄링 가능성 분석이 이루어짐 만약, 스케줄링 도중 새로운 실시간 태스크가 들어오면 그 순간 새로 도착한
    태스크를 포함한 분석이 이루어지고 더 들어올수 있다고 판단
    * 동적 최선 방식
